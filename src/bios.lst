ca65 V2.18 - Ubuntu 2.19-1
Main file   : bios.s
Current file: bios.s

000000r 1               ;****************************************************************************
000000r 1               ;----------------------------------------------------------------------------
000000r 1               ; Monitor program source code for 6502 Microprocessor Kit
000000r 1               ; Written by Paulo Da Silva(pgordao), ppsilv@gmail.com
000000r 1               ; Copyright (c) 2024
000000r 1               ; Serial 16c550 driver
000000r 1               ;
000000r 1               ; Version.: 0.0.5
000000r 1               ;
000000r 1               ; The version 0.0.3 does not has the change of read and write bytes to support msbasic.
000000r 1               ; The version 0.0.5:
000000r 1               ; Changed the absolute address to .res for variables in pagezero
000000r 1               ; Added Fill command: F ADDR_FROM ADDR_TO VALUE
000000r 1               ; Added Block command a block copy: B ADDR_FROM ADDR_TO
000000r 1               ; Changed the code structure all commands gets its own files .s
000000r 1               ;
000000r 1               
000000r 1               .setcpu "6502"
000000r 1               
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1  xx           RACC    : .res 1  ;;= $30               ;;: .res 1
000001r 1  xx           RPHY    : .res 1  ;;= $31               ;;: .res 1
000002r 1  xx           RPHX    : .res 1  ;;= $32               ;;: .res 1
000003r 1  xx           MSGL    : .res 1  ;;= $33
000004r 1  xx           MSGH    : .res 1  ;;= $34
000005r 1  xx           TMP     : .res 1  ;;= $35              ;;TEMPORARY REGISTERS
000006r 1  xx           TMP1    : .res 1  ;;= $36
000007r 1  xx           TMP2    : .res 1  ;;= $37
000008r 1  xx           LAST_CMD: .res 1  ;;= $38
000009r 1  xx           ADDR1L  : .res 1  ;;= $39          ; Digito 4 A do hexa 0xABCD
00000Ar 1  xx           ADDR1H  : .res 1  ;;= $3A          ; Digito 3 B do hexa 0xABCD
00000Br 1  xx           ADDR2L  : .res 1  ;;= $3B          ; Digito 2 C do hexa 0xABCD
00000Cr 1  xx           ADDR2H  : .res 1  ;;= $3C          ; Digito 1 D do hexa 0xABCD
00000Dr 1               ;LEN     : .res 2
00000Dr 1  xx           BSZ     : .res 1  ;;= $3D          ; string size in buffer
00000Er 1  xx           ERRO    : .res 1  ;;= $3E          ; CODIGO DO ERRO
00000Fr 1  xx           COUNTER : .res 1  ;;= $3F
000010r 1  xx           FLAGECHO: .res 1  ;;= $40          ; This flag must contain 00 to disable character echo
000011r 1               
000011r 1               
000011r 1               .DEFINE VERSION "0.0.5"
000011r 1               
000011r 1               .segment "BIOS"
000000r 1               BIN      = $200          ; Buffer size = 128 bytes
000000r 1               ERR01    = $01          ; Conversion error in CONV_HEX_4DIG_FIM
000000r 1               ERR02    = $02          ; Syntax erro in cmd copy memory block.
000000r 1               ERR03    = $03          ; Syntax erro in fill memory block.
000000r 1               
000000r 1               ;*************************************************************
000000r 1               ;*************************************************************
000000r 1               ; RESET
000000r 1               ;*************************************************************
000000r 1               ;*************************************************************
000000r 1               
000000r 1               RESET:
000000r 1  78           	            SEI					; No interrupt
000001r 1  D8           	            CLD					; Set decimal
000002r 1  A2 FE        	            LDX #$FE 			; Set stack pointer
000004r 1  9A           	            TXS
000005r 1               
000005r 1                               ;;Initializing some variables
000005r 1  A9 00                        LDA     #$00
000007r 1  85 rr                        STA     ADDR1L
000009r 1  85 rr                        STA     ADDR1H
00000Br 1  85 rr                        STA     ADDR2L
00000Dr 1  85 rr                        STA     ADDR2H
00000Fr 1  85 rr                        STA     FLAGECHO
000011r 1                               ;;Initialize PIA
000011r 1                               ;;JSR     INIT8255
000011r 1                               ;;Initialize ACIA
000011r 1  20 rr rr                     JSR     INITUART
000014r 1  A9 rr                        LDA     #<MSG1
000016r 1  85 rr                        STA     MSGL
000018r 1  A9 rr                        LDA     #>MSG1
00001Ar 1  85 rr                        STA     MSGH
00001Cr 1  20 rr rr                     JSR     SHWMSG
00001Fr 1                               ;;Turn off flag echo
00001Fr 1  20 rr rr                     JSR     DIGITOU_AST
000022r 1               NEXT_CHAR:
000022r 1               ;               LDX     #$FF
000022r 1               ;                CPX     FLAGECHO
000022r 1                               ;BNE     NO_LF
000022r 1  A9 0D                        LDA     #$0D
000024r 1  20 rr rr                     JSR     WRITE_BYTE
000027r 1               ;NO_LF:
000027r 1  A9 3E                        LDA     #'>'
000029r 1  20 rr rr                     JSR     WRITE_BYTE
00002Cr 1  20 rr rr                     JSR     READ_BYTE
00002Fr 1               
00002Fr 1  A2 00                        LDX     #$00
000031r 1  E4 rr                        CPX     FLAGECHO
000033r 1  D0 03                        BNE     NO_ECHO
000035r 1  20 rr rr                     JSR     WRITE_BYTE
000038r 1               NO_ECHO:
000038r 1  C9 2A                        CMP     #'*'            ;Turn on/off character echo
00003Ar 1  F0 34                        BEQ     TEMP_AST
00003Cr 1  C9 42                        CMP     #'B'            ;Copy memory block from source to dest
00003Er 1  F0 1B                        BEQ     TEMP_B
000040r 1  C9 44                        CMP     #'D'            ;Dump memory block from source to dest
000042r 1  F0 1A                        BEQ     TEMP_D
000044r 1  C9 46                        CMP     #'F'            ;Fill memory block with a value
000046r 1  F0 19                        BEQ     TEMP_F
000048r 1  C9 4D                        CMP     #'M'            ;(POKE)Put byte into memory address
00004Ar 1  F0 18                        BEQ     TEMP_M
00004Cr 1  C9 50                        CMP     #'P'            ;(PEEK)get byte frin memoria ADDR:ADDR
00004Er 1  F0 17                        BEQ     TEMP_P
000050r 1  C9 52                        CMP     #'R'            ;Run programa na format: ADDR R
000052r 1  F0 16                        BEQ     TEMP_R
000054r 1  C9 3F                        CMP     #'?'            ;Show help
000056r 1  F0 15                        BEQ     TEMP_H
000058r 1  4C rr rr                     JMP     NEXT_CHAR
00005Br 1  4C rr rr     TEMP_B:         JMP     CMD_CP_BLOCK
00005Er 1  4C rr rr     TEMP_D:         JMP     CMD_DUMP
000061r 1  4C rr rr     TEMP_F:         JMP     CMD_FILL
000064r 1  4C rr rr     TEMP_M:         JMP     CMD_POKE
000067r 1  4C rr rr     TEMP_P:         JMP     CMD_PEEK
00006Ar 1  4C rr rr     TEMP_R:         JMP     CMD_RUN
00006Dr 1  4C rr rr     TEMP_H:         JMP     CMD_HELP
000070r 1  4C rr rr     TEMP_AST:       JMP     DIGITOU_AST
000073r 1               
000073r 1               
000073r 1               .include "utils.s"
000073r 2  xx           RESULT_H  : .res 1
000074r 2  xx           RESULT_L  : .res 1
000075r 2               DADO1_L   = ADDR1L
000075r 2               DADO1_H   = ADDR1H
000075r 2               DADO2_L   = ADDR2L
000075r 2               DADO2_H   = ADDR2H
000075r 2               FROM      = ADDR1L
000075r 2               TO        = ADDR2L
000075r 2  xx xx        LENGHT    : .res 2
000077r 2               
000077r 2               
000077r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000077r 2               ; Convert 2 bytes ascii in 1 byte hexa
000077r 2               ; Ex.: 41 35 = $A5
000077r 2               ; Input : RPHX with byte to be converted
000077r 2               ;         RPHY with byte to be converted
000077r 2               ; Ouput : TMP with byte converted
000077r 2               ; Registers affected: A
000077r 2               ;
000077r 2               CONV_ASCII_2_HEX:
000077r 2                               ;;Digit high byte
000077r 2  A5 rr                        LDA     RPHX
000079r 2  20 rr rr                     JSR     ROL_LEFT
00007Cr 2                              ; BCC     @FIM
00007Cr 2  85 rr                        STA     TMP
00007Er 2                               ;;Digit Low byte
00007Er 2  A5 rr                        LDA     RPHY
000080r 2  20 rr rr                     JSR     GET_DIG_RIGHT
000083r 2                              ; BCC     @FIM
000083r 2  05 rr                        ORA     TMP
000085r 2  85 rr                        STA     TMP
000087r 2  A5 rr                        LDA     TMP
000089r 2               @FIM:
000089r 2  60                           RTS
00008Ar 2               
00008Ar 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00008Ar 2               ; Convert a number in Acc frp, HEX to ASCII
00008Ar 2               ; Input.: Acc number to be converted
00008Ar 2               ; Output: Acc number converted
00008Ar 2               ; Registers affected: A
00008Ar 2               ; The data must be in 01 to 0F
00008Ar 2               ; OBS: THIS ROUTINE ASSUMES THE VALUE IN ACC IS A VALID
00008Ar 2               ;      HEXACIMAL
00008Ar 2               ;
00008Ar 2               HEX_2_ASC:
00008Ar 2  C9 0A                    CMP     #$A
00008Cr 2  90 02                    BCC     IT_IS_NUMBER
00008Er 2  69 06                    ADC     #6
000090r 2               IT_IS_NUMBER:
000090r 2  69 30                    ADC     #$30
000092r 2  60                       RTS
000093r 2               
000093r 2               ASC_2_HEX:
000093r 2  C9 3A                    CMP     #$3A
000095r 2  90 03                    BCC     @IT_IS_NUMBER
000097r 2  18                       CLC
000098r 2  E9 07                    SBC     #7
00009Ar 2               @IT_IS_NUMBER:
00009Ar 2  E9 2F                    SBC     #$2F
00009Cr 2  60                       RTS
00009Dr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00009Dr 2               ;PRINT_HEXA: Print the data hexadecimal in Acc
00009Dr 2               ; Inputs: Acc = byte to be printed
00009Dr 2               ;
00009Dr 2               ; Registers affected: A
00009Dr 2               ;
00009Dr 2               PRINT_HEXA:
00009Dr 2  48                       PHA
00009Er 2  20 rr rr                 JSR    ROTATE_RIGHT
0000A1r 2  20 rr rr                 JSR    PRHIGH_NIBBLE
0000A4r 2  68                       PLA
0000A5r 2  29 0F                    AND    #$0F
0000A7r 2               PRHIGH_NIBBLE:
0000A7r 2  20 rr rr                 JSR    HEX_2_ASC
0000AAr 2  20 rr rr                 JSR    WRITE_BYTE
0000ADr 2  60                       RTS             ;*Done, over and out...
0000AEr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000AEr 2               ; The same as PRINT_HEXA
0000AEr 2               ;PRBYTE:     PHA             ;Save A for LSD.
0000AEr 2               ;            LSR
0000AEr 2               ;            LSR
0000AEr 2               ;            LSR             ;MSD to LSD position.
0000AEr 2               ;            LSR
0000AEr 2               ;            JSR PRHEX       ;Output hex digit.
0000AEr 2               ;            PLA             ;Restore A.
0000AEr 2               ;PRHEX:      AND #$0F        ;Mask LSD for hex print.
0000AEr 2               ;            ORA #$B0        ;Add "0".
0000AEr 2               ;            CMP #$BA        ;Digit?
0000AEr 2               ;            BCC ECHO        ;Yes, output it.
0000AEr 2               ;            ADC #$06        ;Add offset for letter.
0000AEr 2               ;ECHO:
0000AEr 2               ;            AND #$7F        ;*Change to "standard ASCII"
0000AEr 2               ;            JSR  WRITE_BYTE
0000AEr 2               ;            RTS             ;*Done, over and out...
0000AEr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000AEr 2               ; Copy memory block with size below 256
0000AEr 2               ; Inputs: BASE = Address origin of copy
0000AEr 2               ;         DEST = Address destiny of copy
0000AEr 2               ;         LENGHT = Total of bytes to copy
0000AEr 2               ; Registers affected: A, X
0000AEr 2               ;
0000AEr 2               COPY_BLK_255:
0000AEr 2  AE rr rr             LDX     LENGHT
0000B1r 2               NEXT_BYTE:
0000B1r 2  B5 rr                LDA     FROM, X
0000B3r 2  95 rr                STA     TO,X
0000B5r 2  CA                   DEX
0000B6r 2  D0 F9                BNE     NEXT_BYTE
0000B8r 2  60                   RTS
0000B9r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000B9r 2               ; Sum 2 16bits data
0000B9r 2               ; DADO1 + DADO2 = RESULT
0000B9r 2               ; Registers affected: A
0000B9r 2               ;
0000B9r 2               SUM_2_16BITS:
0000B9r 2  18                   CLC
0000BAr 2  A5 rr                LDA     DADO1_L
0000BCr 2  65 rr                ADC     DADO2_L
0000BEr 2  8D rr rr             STA     RESULT_L
0000C1r 2  A5 rr                LDA     DADO1_H
0000C3r 2  65 rr                ADC     DADO2_H
0000C5r 2  8D rr rr             STA     RESULT_H
0000C8r 2  60                   RTS
0000C9r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000C9r 2               ; Subtract 2 16bits data
0000C9r 2               ; DADO1 - DADO2 = RESULT
0000C9r 2               ; Registers affected: A
0000C9r 2               ;
0000C9r 2               SUBTRACT_2_16BITS:
0000C9r 2  38                   SEC
0000CAr 2  A5 rr                LDA     DADO1_L
0000CCr 2  E5 rr                SBC     DADO2_L
0000CEr 2  8D rr rr             STA     RESULT_L
0000D1r 2  A5 rr                LDA     DADO1_H
0000D3r 2  E5 rr                SBC     DADO2_H
0000D5r 2  8D rr rr             STA     RESULT_H
0000D8r 2  60                   RTS
0000D9r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000D9r 2               ; Inc Address
0000D9r 2               ; Registers affected: A
0000D9r 2               ;
0000D9r 2               INC_ADDR:
0000D9r 2  18                       CLC
0000DAr 2  A9 01                    LDA #$01
0000DCr 2  65 rr                    ADC ADDR1L
0000DEr 2  85 rr                    STA ADDR1L
0000E0r 2  A9 00                    LDA #$00
0000E2r 2  65 rr                    ADC ADDR1H
0000E4r 2  85 rr                    STA ADDR1H
0000E6r 2  60                       RTS
0000E7r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000E7r 2               ; Compara enderecos
0000E7r 2               ; Registers affected: None
0000E7r 2               ;
0000E7r 2               COMP_ADDR:
0000E7r 2  A5 rr                    LDA ADDR1H
0000E9r 2  C5 rr                    CMP ADDR2H
0000EBr 2  D0 04                    BNE COMP_ADDR_FIM
0000EDr 2  A5 rr                    LDA ADDR1L
0000EFr 2  C5 rr                    CMP ADDR2L
0000F1r 2               COMP_ADDR_FIM:
0000F1r 2  60                       RTS
0000F2r 2               
0000F2r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000F2r 2               ; ROTATE_RIGHT:
0000F2r 2               ; Rotate the Acc 4 times to right and get the hy nibble of
0000F2r 2               ; acumulator.
0000F2r 2               ; Registers affected: A
0000F2r 2               ;
0000F2r 2               ROTATE_RIGHT:
0000F2r 2  6A                           ROR
0000F3r 2  6A                           ROR
0000F4r 2  6A                           ROR
0000F5r 2  6A                           ROR
0000F6r 2  29 0F                        AND     #$0F
0000F8r 2  60                           RTS
0000F9r 2               
0000F9r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0000F9r 2               ;GET_ADDRESS:     Get input from keyboard and put it in BIN
0000F9r 2               ; Inputs: NONE
0000F9r 2               ;
0000F9r 2               ; Registers affected: A, Y
0000F9r 2               ;
0000F9r 2               GET_ADDRESS:
0000F9r 2  A9 rr                        LDA     #<MSG2
0000FBr 2  85 rr                        STA     MSGL
0000FDr 2  A9 rr                        LDA     #>MSG2
0000FFr 2  85 rr                        STA     MSGH
000101r 2  20 rr rr                     JSR     SHWMSG
000104r 2  20 rr rr                     JSR     GETLINE
000107r 2  A9 00                        LDA     #<BIN
000109r 2  85 rr                        STA     MSGL
00010Br 2  A9 02                        LDA     #>BIN
00010Dr 2  85 rr                        STA     MSGH
00010Fr 2  20 rr rr                     JSR     SHWMSG
000112r 2  60                           RTS
000113r 2               
000113r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000113r 2               ;SHWMSG: Show message from pointer MSGL in FP
000113r 2               ; Inputs: MSGL
000113r 2               ;
000113r 2               ; Registers affected: A, Y
000113r 2               ;
000113r 2               ;
000113r 2               SHWMSG:
000113r 2  A0 00                        LDY #$0
000115r 2               SMSG:
000115r 2  B1 rr                        LDA (MSGL),Y
000117r 2  F0 06                        BEQ SMDONE
000119r 2  20 rr rr                     JSR WRITE_BYTE
00011Cr 2  C8                           INY
00011Dr 2  D0 F6                        BNE SMSG
00011Fr 2               SMDONE:
00011Fr 2  60                           RTS
000120r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000120r 2               ; Subtract (TMP Acc) - (TMP2 TMP1)
000120r 2               ; TMP High byte   TMP2 High byte
000120r 2               ; Acc Low byte    TMP1 low byte
000120r 2               ; Result in TMP2,TMP1
000120r 2               ;
000120r 2               SUBTRACT_2_BYTES:
000120r 2  38               SEC
000121r 2  E5 rr            SBC     TMP1
000123r 2  85 rr            STA     TMP1
000125r 2  A5 rr            LDA     TMP
000127r 2  E5 rr            SBC     TMP2
000129r 2  85 rr            STA     TMP2
00012Br 2  60               RTS
00012Cr 2               
00012Cr 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00012Cr 2               ;GETLINE: Get data inputed from keyboard and
00012Cr 2               ;         put it into buffer BIN
00012Cr 2               ; Inputs: NONE
00012Cr 2               ;
00012Cr 2               ; Registers affected: A, Y
00012Cr 2               ;
00012Cr 2  A0 00        GETLINE:        LDY     #$00
00012Er 2  20 rr rr     GETLINE1:       JSR     READ_BYTE
000131r 2                               ;JSR     WRITE_BYTE
000131r 2  99 00 02                     STA     BIN,Y
000134r 2  C8                           INY
000135r 2  C9 0D                        CMP     #$0D
000137r 2  D0 F5                        BNE     GETLINE1
000139r 2  A9 00                        LDA     #$00
00013Br 2  99 00 02                     STA     BIN,Y
00013Er 2  84 rr                        STY     BSZ
000140r 2  60                           RTS
000141r 2               
000141r 2               ROL_LEFT:
000141r 2  20 rr rr                     JSR     ASC_2_HEX
000144r 2  2A                           ROL
000145r 2  2A                           ROL
000146r 2  2A                           ROL
000147r 2  2A                           ROL
000148r 2  29 F0                        AND     #$F0
00014Ar 2  60                           RTS
00014Br 2               
00014Br 2               GET_DIG_RIGHT:
00014Br 2  20 rr rr                     JSR     ASC_2_HEX
00014Er 2  29 0F                        AND     #$0F
000150r 2  60                           RTS
000151r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000151r 2               ;CONV_ADDR_TO_HEX:
000151r 2               ; Ex.: 46 45 31 30 = $FE10
000151r 2               ; Convert 4 bytes ASCII in 2 bytes hexa.
000151r 2               ;
000151r 2               CONV_ADDR_TO_HEX:
000151r 2                               ;;Dig 4
000151r 2  B9 00 02                     LDA     BIN,Y
000154r 2  85 rr                        STA     RPHX
000156r 2                               ;;Dig 3
000156r 2  C8                           INY
000157r 2  B9 00 02                     LDA     BIN,Y
00015Ar 2  85 rr                        STA     RPHY
00015Cr 2  20 rr rr                     JSR     CONV_ASCII_2_HEX
00015Fr 2                               ;BCC     @FIM
00015Fr 2  85 rr                        STA     TMP1
000161r 2                               ;;Dig 2
000161r 2  C8                           INY
000162r 2  B9 00 02                     LDA     BIN,Y
000165r 2  85 rr                        STA     RPHX
000167r 2                               ;;Dig 1
000167r 2  C8                           INY
000168r 2  B9 00 02                     LDA     BIN,Y
00016Br 2  85 rr                        STA     RPHY
00016Dr 2  20 rr rr                     JSR     CONV_ASCII_2_HEX
000170r 2                               ;BCC     @FIM
000170r 2  85 rr                        STA     TMP2
000172r 2               
000172r 2  38                           SEC
000173r 2  60                           RTS
000174r 2               ;@FIM:
000174r 2  60                           RTS
000175r 2               
000175r 2               SWAP_XY:
000175r 2  84 rr                        STY     TMP     ; Y 2 M
000177r 2  8A                           TXA             ; X 2 A
000178r 2  A8                           TAY             ; A 2 Y
000179r 2  A6 rr                        LDX     TMP     ; M 2 X
00017Br 2  60                           RTS
00017Cr 2               
00017Cr 2               FORMAT_ADDRESS:
00017Cr 2                           ;Get addr from
00017Cr 2  A0 00                    LDY     #$00
00017Er 2  20 rr rr                 JSR     CONV_ADDR_TO_HEX
000181r 2  90 4A                    BCC     FORMAT_FIM
000183r 2  A6 rr                    LDX     TMP1
000185r 2  A4 rr                    LDY     TMP2
000187r 2  20 rr rr                 JSR     SWAP_XY
00018Ar 2  86 rr                    STX     ADDR1L
00018Cr 2  84 rr                    STY     ADDR1H
00018Er 2               
00018Er 2  A0 04                    LDY     #$04
000190r 2  B9 00 02                 LDA     BIN,Y
000193r 2  C9 2E                    CMP     #'.'
000195r 2  D0 31                    BNE     FORMAT_ERROR
000197r 2               
000197r 2                           ;Get addr to
000197r 2  A0 05                    LDY     #$05
000199r 2  20 rr rr                 JSR     CONV_ADDR_TO_HEX
00019Cr 2  90 2F                    BCC     FORMAT_FIM
00019Er 2  A6 rr                    LDX     TMP1
0001A0r 2  A4 rr                    LDY     TMP2
0001A2r 2  20 rr rr                 JSR     SWAP_XY
0001A5r 2  86 rr                    STX     ADDR2L
0001A7r 2  84 rr                    STY     ADDR2H
0001A9r 2  60                       RTS
0001AAr 2               FORMAT_16BITS_DATA:
0001AAr 2  A0 09                    LDY     #$09
0001ACr 2  B9 00 02                 LDA     BIN,Y
0001AFr 2  C9 3A                    CMP     #':'
0001B1r 2  D0 15                    BNE     FORMAT_ERROR
0001B3r 2  A0 0A                    LDY     #$0A
0001B5r 2  20 rr rr                 JSR     CONV_ADDR_TO_HEX
0001B8r 2  90 13                    BCC     FORMAT_FIM
0001BAr 2  A6 rr                    LDX     TMP1
0001BCr 2  A4 rr                    LDY     TMP2
0001BEr 2  20 rr rr                 JSR     SWAP_XY
0001C1r 2  8E rr rr                 STX     LENGHT
0001C4r 2  8C rr rr                 STY     LENGHT+1
0001C7r 2  60                       RTS
0001C8r 2               FORMAT_ERROR:
0001C8r 2  A5 03                    LDA     ERR03
0001CAr 2  4C rr rr                 JMP     SYNTAX_ERROR
0001CDr 2               FORMAT_FIM:
0001CDr 2  4C rr rr                 JMP     NEXT_CHAR
0001D0r 2               ;;********************************************
0001D0r 2               ;;Print 4 digits hexadecimal
0001D0r 2               ;PRINT_ADDR_HEXA:
0001D0r 2               ;                LDA     #'['
0001D0r 2               ;                JSR     WRITE_BYTE
0001D0r 2               ;                LDA     ADDR1H
0001D0r 2               ;                JSR     PRINT_HEXA ;PRBYTE
0001D0r 2               ;                LDA     ADDR1L
0001D0r 2               ;                JSR     PRBYTE
0001D0r 2               ;                LDA     LAST_CMD
0001D0r 2               ;                CMP     #'D'
0001D0r 2               ;                BNE     PRINT_ADDR_HEXA_1
0001D0r 2               ;                LDA     #'.'
0001D0r 2               ;                JSR     WRITE_BYTE
0001D0r 2               ;PRINT_ADDR_HEXA_1:
0001D0r 2               ;                LDA     ADDR2H
0001D0r 2               ;                JSR     PRINT_HEXA ;PRBYTE
0001D0r 2               ;                LDA     ADDR2L
0001D0r 2               ;                JSR     PRBYTE
0001D0r 2               ;                LDA     #']'
0001D0r 2               ;                JSR     WRITE_BYTE
0001D0r 2               ;                RTS
0001D0r 2               
0001D0r 2               
0001D0r 2               ;;;
0001D0r 2               ;;; EXPERIMENTAL
0001D0r 2               ;;;
0001D0r 2               
0001D0r 2               
0001D0r 2               
0001D0r 1               .include "cmd_cblock.s"
0001D0r 2               ;SOURCE = $1000
0001D0r 2               ;DEST   = $2000
0001D0r 2               ;LENGHT: .res 2
0001D0r 2               ;FROM   = ADDR1L
0001D0r 2               ;TO     = ADDR2L
0001D0r 2               
0001D0r 2               CMD_CP_BLOCK:
0001D0r 2                       ;    ;Load address from
0001D0r 2                       ;    LDA     #<SOURCE
0001D0r 2                       ;    STA     FROM
0001D0r 2                       ;    ;JSR     PRBYTE
0001D0r 2               ;
0001D0r 2                       ;    LDA     #>SOURCE
0001D0r 2                       ;    STA     FROM+1
0001D0r 2                       ;    ;JSR     PRBYTE
0001D0r 2                       ;    ;Load address to
0001D0r 2                       ;    LDA     #<DEST
0001D0r 2                       ;    STA     TO
0001D0r 2                       ;    ;JSR     PRBYTE
0001D0r 2               ;
0001D0r 2                       ;    LDA     #>DEST
0001D0r 2                       ;    STA     TO+1
0001D0r 2                       ;    ;JSR     PRBYTE
0001D0r 2               
0001D0r 2  85 rr                    STA     LAST_CMD
0001D2r 2  A9 rr                    LDA     #<MSG8
0001D4r 2  85 rr                    STA     MSGL
0001D6r 2  A9 rr                    LDA     #>MSG8
0001D8r 2  85 rr                    STA     MSGH
0001DAr 2  20 rr rr                 JSR     SHWMSG
0001DDr 2  20 rr rr                 JSR     GETLINE
0001E0r 2               
0001E0r 2  20 rr rr                 JSR     FORMAT_ADDRESS
0001E3r 2  20 rr rr                 JSR     FORMAT_16BITS_DATA
0001E6r 2               
0001E6r 2                           ;Load how many blocks to copy
0001E6r 2  A2 rr                    LDX     #>LENGHT
0001E8r 2                           ;Block size
0001E8r 2  F0 14                    BEQ     REMAIN      ;Handle < $100
0001EAr 2  A0 FF                    LDY     #$FF        ;Copy from top
0001ECr 2                           ;Do it
0001ECr 2               NEXT:
0001ECr 2  B1 rr                    LDA     (FROM),Y    ;Read element
0001EEr 2  91 rr                    STA     (TO),Y      ;Save it to destiny
0001F0r 2  88                       DEY                 ;Update pointer
0001F1r 2  C0 FF                    CPY     #$FF        ;Dowm to 0
0001F3r 2  D0 F7                    BNE     NEXT        ;Finished?
0001F5r 2               NEXTBLK:
0001F5r 2  E6 rr                    INC     FROM+1      ;Increment block pointer FROM
0001F7r 2  E6 rr                    INC     TO+1        ;Same to pointer TO
0001F9r 2  CA                       DEX                 ;Block counter
0001FAr 2  30 09                    BMI     DONE
0001FCr 2  D0 EE                    BNE     NEXT
0001FEr 2               REMAIN:
0001FEr 2  A0 rr                    LDY     #<LENGHT    ;Add remain lable
000200r 2  F0 03                    BEQ     DONE        ;handle no remain
000202r 2  88                       DEY                 ;Fix extra byte bug
000203r 2  D0 E7                    BNE     NEXT
000205r 2               DONE:
000205r 2  4C rr rr                 JMP     NEXT_CHAR
000208r 2               
000208r 2               
000208r 2               
000208r 2               
000208r 1               .include "cmd_dump.s"
000208r 2               CMD_DUMP:
000208r 2  85 rr                        STA     LAST_CMD
00020Ar 2  A9 rr                        LDA     #<MSG3
00020Cr 2  85 rr                        STA     MSGL
00020Er 2  A9 rr                        LDA     #>MSG3
000210r 2  85 rr                        STA     MSGH
000212r 2  20 rr rr                     JSR     SHWMSG
000215r 2  20 rr rr                     JSR     GETLINE
000218r 2                               ;Get addr from
000218r 2  A0 00                        LDY     #$00
00021Ar 2  20 rr rr                     JSR     CONV_ADDR_TO_HEX
00021Dr 2  A6 rr                        LDX     TMP1
00021Fr 2  A4 rr                        LDY     TMP2
000221r 2  20 rr rr                     JSR     SWAP_XY
000224r 2  86 rr                        STX     ADDR1L
000226r 2  84 rr                        STY     ADDR1H
000228r 2               
000228r 2  A0 04                        LDY     #$04
00022Ar 2  B9 00 02                     LDA     BIN,Y
00022Dr 2  C9 2E                        CMP     #'.'
00022Fr 2  D0 49                        BNE     DIGITOU_D_SHOWMEM
000231r 2               
000231r 2                               ;Get addr to
000231r 2  A0 05                        LDY     #$05
000233r 2  20 rr rr                     JSR     CONV_ADDR_TO_HEX
000236r 2  A6 rr                        LDX     TMP1
000238r 2  A4 rr                        LDY     TMP2
00023Ar 2  20 rr rr                     JSR     SWAP_XY
00023Dr 2  86 rr                        STX     ADDR2L
00023Fr 2  84 rr                        STY     ADDR2H
000241r 2               
000241r 2                               ;JSR     PRINT_ADDR_HEXA
000241r 2               
000241r 2  A9 08                        LDA     #$08
000243r 2  85 rr                        STA     TMP2
000245r 2  A2 08        LINHA:          LDX     #$08
000247r 2  A9 0D                        LDA     #$0D
000249r 2  20 rr rr                     JSR     WRITE_BYTE
00024Cr 2  A5 rr                        LDA     ADDR1H
00024Er 2  20 rr rr                     JSR     PRINT_HEXA
000251r 2  A5 rr                        LDA     ADDR1L
000253r 2  20 rr rr                     JSR     PRINT_HEXA
000256r 2  A9 20                        LDA     #' '
000258r 2  20 rr rr                     JSR     WRITE_BYTE
00025Br 2               DIGITOU_D_WORK:
00025Br 2                               ;addressing mode of 65C02
00025Br 2                               ;LDA     (ADDR1L)
00025Br 2                               ;addressing mode of 6502
00025Br 2  A0 00                        LDY     #$0
00025Dr 2                               ;to work ADDR1L must be in zeropage
00025Dr 2                               ;and register must be Y
00025Dr 2  B1 rr                        LDA     (ADDR1L),Y
00025Fr 2                               ;******************
00025Fr 2  20 rr rr                     JSR     PRINT_HEXA
000262r 2  A9 20                        LDA     #' '
000264r 2  20 rr rr                     JSR     WRITE_BYTE
000267r 2  20 rr rr                     JSR     INC_ADDR
00026Ar 2  20 rr rr                     JSR     COMP_ADDR
00026Dr 2  F0 EC                        BEQ     DIGITOU_D_WORK
00026Fr 2  B0 06                        BCS     DIGITOU_D_FIM
000271r 2                               ;JSR     PRINT_ADDR_HEXA
000271r 2                               ;JSR     READ_BYTE
000271r 2  CA                           DEX
000272r 2  F0 D1                        BEQ     LINHA
000274r 2  4C rr rr                     JMP     DIGITOU_D_WORK
000277r 2               DIGITOU_D_FIM:
000277r 2  4C rr rr                     JMP     NEXT_CHAR
00027Ar 2               DIGITOU_D_SHOWMEM:
00027Ar 2  A0 04                        LDY     #$04
00027Cr 2  B9 00 02                     LDA     BIN,Y
00027Fr 2  C9 3A                        CMP     #$3A
000281r 2  F0 16                        BEQ     DIGITOU_D_SHOWMEM_FIM
000283r 2  A5 rr                        LDA     ADDR1H
000285r 2  20 rr rr                     JSR     PRINT_HEXA
000288r 2  A5 rr                        LDA     ADDR1L
00028Ar 2  20 rr rr                     JSR     PRINT_HEXA
00028Dr 2  A9 20                        LDA     #' '
00028Fr 2  20 rr rr                     JSR     WRITE_BYTE
000292r 2                               ;addressing mode of 65C02
000292r 2                               ;LDA     (ADDR1L)
000292r 2                               ;addressing mode of 6502
000292r 2  A0 00                        LDY     #$0
000294r 2  B1 rr                        LDA     (ADDR1L),Y
000296r 2               
000296r 2  20 rr rr                     JSR     PRINT_HEXA
000299r 2               DIGITOU_D_SHOWMEM_FIM:
000299r 2  4C rr rr                     JMP     NEXT_CHAR
00029Cr 2               
00029Cr 2               
00029Cr 1               .include "cmd_echo.s"
00029Cr 2               DIGITOU_AST:
00029Cr 2  A9 rr                        LDA     #<MSG10
00029Er 2  85 rr                        STA     MSGL
0002A0r 2  A9 rr                        LDA     #>MSG10
0002A2r 2  85 rr                        STA     MSGH
0002A4r 2  20 rr rr                     JSR     SHWMSG
0002A7r 2  A5 rr                        LDA     FLAGECHO
0002A9r 2  49 FF                        EOR     #$FF
0002ABr 2  85 rr                        STA     FLAGECHO
0002ADr 2  4C rr rr                     JMP     NEXT_CHAR
0002B0r 2               
0002B0r 1               .include "cmd_fill.s"
0002B0r 2               
0002B0r 2               CMD_FILL:
0002B0r 2  85 rr                    STA     LAST_CMD
0002B2r 2  A9 rr                    LDA     #<MSG11
0002B4r 2  85 rr                    STA     MSGL
0002B6r 2  A9 rr                    LDA     #>MSG11
0002B8r 2  85 rr                    STA     MSGH
0002BAr 2  20 rr rr                 JSR     SHWMSG
0002BDr 2  20 rr rr                 JSR     GETLINE
0002C0r 2                           ;Get addr from
0002C0r 2  A0 00                    LDY     #$00
0002C2r 2  20 rr rr                 JSR     CONV_ADDR_TO_HEX
0002C5r 2  90 53                    BCC     FIM_CMD_FILL
0002C7r 2  A6 rr                    LDX     TMP1
0002C9r 2  A4 rr                    LDY     TMP2
0002CBr 2  20 rr rr                 JSR     SWAP_XY
0002CEr 2  86 rr                    STX     ADDR1L
0002D0r 2  84 rr                    STY     ADDR1H
0002D2r 2               
0002D2r 2  A0 04                    LDY     #$04
0002D4r 2  B9 00 02                 LDA     BIN,Y
0002D7r 2  C9 2E                    CMP     #'.'
0002D9r 2  D0 42                    BNE     FILL_BLOCK_SYNTAX_ERROR
0002DBr 2               
0002DBr 2                           ;Get addr to
0002DBr 2  A0 05                    LDY     #$05
0002DDr 2  20 rr rr                 JSR     CONV_ADDR_TO_HEX
0002E0r 2  90 38                    BCC     FIM_CMD_FILL
0002E2r 2  A6 rr                    LDX     TMP1
0002E4r 2  A4 rr                    LDY     TMP2
0002E6r 2  20 rr rr                 JSR     SWAP_XY
0002E9r 2  86 rr                    STX     ADDR2L
0002EBr 2  84 rr                    STY     ADDR2H
0002EDr 2               
0002EDr 2  A0 09                    LDY     #$09
0002EFr 2  B9 00 02                 LDA     BIN,Y
0002F2r 2  C9 3A                    CMP     #':'
0002F4r 2  D0 27                    BNE     FILL_BLOCK_SYNTAX_ERROR
0002F6r 2               
0002F6r 2                           ;Get data to fill
0002F6r 2  A0 0A                    LDY     #$0A
0002F8r 2  B9 00 02                 LDA     BIN,Y
0002FBr 2  85 rr                    STA     RPHX
0002FDr 2  C8                       INY
0002FEr 2  B9 00 02                 LDA     BIN,Y
000301r 2  85 rr                    STA     RPHY
000303r 2  20 rr rr                 JSR     CONV_ASCII_2_HEX
000306r 2               
000306r 2                           ;JSR     PRINT_ADDR_HEXA
000306r 2               FILL:
000306r 2  A0 00                    LDY     #$0
000308r 2  A5 rr                    LDA     TMP
00030Ar 2  91 rr                    STA     (ADDR1L),Y
00030Cr 2  20 rr rr                 JSR     INC_ADDR
00030Fr 2  20 rr rr                 JSR     COMP_ADDR
000312r 2  90 F2                    BCC     FILL
000314r 2  A0 00                    LDY     #$0
000316r 2  A5 rr                    LDA     TMP
000318r 2  91 rr                    STA     (ADDR1L),Y
00031Ar 2               
00031Ar 2               FIM_CMD_FILL:
00031Ar 2  4C rr rr                 JMP     NEXT_CHAR
00031Dr 2               
00031Dr 2               FILL_BLOCK_SYNTAX_ERROR:
00031Dr 2  A5 03                    LDA     ERR03
00031Fr 2  4C rr rr                 JMP     SYNTAX_ERROR
000322r 2               
000322r 1               .include "cmd_peek.s"
000322r 2               CMD_PEEK:
000322r 2               
000322r 2  4C rr rr                 JMP     NEXT_CHAR
000325r 2               
000325r 1               .include "cmd_poke.s"
000325r 2               CMD_POKE:
000325r 2  85 rr                        STA     LAST_CMD
000327r 2  A9 rr                        LDA     #<MSG7
000329r 2  85 rr                        STA     MSGL
00032Br 2  A9 rr                        LDA     #>MSG7
00032Dr 2  85 rr                        STA     MSGH
00032Fr 2  20 rr rr                     JSR     SHWMSG
000332r 2  20 rr rr                     JSR     GETLINE
000335r 2                               ;Get addr from
000335r 2  A0 00                        LDY     #$00
000337r 2  20 rr rr                     JSR     CONV_ADDR_TO_HEX
00033Ar 2  A6 rr                        LDX     TMP1
00033Cr 2  A4 rr                        LDY     TMP2
00033Er 2  20 rr rr                     JSR     SWAP_XY
000341r 2  86 rr                        STX     ADDR1L
000343r 2  84 rr                        STY     ADDR1H
000345r 2               
000345r 2                               ;VERIFICAR SE O COMANDO É :
000345r 2  A0 04                        LDY     #$04
000347r 2  B9 00 02                     LDA     BIN,Y
00034Ar 2  C9 3A                        CMP     #$3A
00034Cr 2  D0 19                        BNE     DIGITOU_M_FIM
00034Er 2               
00034Er 2  A0 05                        LDY     #$05
000350r 2  B9 00 02                     LDA     BIN,Y
000353r 2  20 rr rr                     JSR     ROL_LEFT
000356r 2  85 rr                        STA     TMP1
000358r 2  C8                           INY
000359r 2  B9 00 02                     LDA     BIN,Y
00035Cr 2  20 rr rr                     JSR     GET_DIG_RIGHT
00035Fr 2  05 rr                        ORA     TMP1
000361r 2  85 rr                        STA     TMP1
000363r 2                               ;addressing mode of 65C02
000363r 2                               ;STA     (ADDR1L)
000363r 2                               ;addressing mode of 6502
000363r 2  A0 00                        LDY     #$0
000365r 2  91 rr                        STA     (ADDR1L),Y
000367r 2               
000367r 2               DIGITOU_M_FIM:
000367r 2  4C rr rr                     JMP     NEXT_CHAR
00036Ar 2               
00036Ar 1               .include "cmd_run.s"
00036Ar 2               CMD_RUN:
00036Ar 2  85 rr                        STA     LAST_CMD
00036Cr 2  A9 rr                        LDA     #<MSG4
00036Er 2  85 rr                        STA     MSGL
000370r 2  A9 rr                        LDA     #>MSG4
000372r 2  85 rr                        STA     MSGH
000374r 2  20 rr rr                     JSR     SHWMSG
000377r 2  20 rr rr                     JSR     GET_ADDRESS
00037Ar 2  A0 00                        LDY     #$00
00037Cr 2  20 rr rr                     JSR     CONV_ADDR_TO_HEX
00037Fr 2  A6 rr                        LDX     TMP1
000381r 2  A4 rr                        LDY     TMP2
000383r 2  20 rr rr                     JSR     SWAP_XY
000386r 2  86 rr                        STX     ADDR1L
000388r 2  84 rr                        STY     ADDR1H
00038Ar 2                               ;JSR     PRINT_ADDR_HEXA
00038Ar 2  6C rr rr                     JMP     (ADDR1L)
00038Dr 2  4C rr rr                     JMP     NEXT_CHAR
000390r 2               
000390r 1               
000390r 1               SYNTAX_ERROR:
000390r 1  A9 rr                        LDA     #<MSG9
000392r 1  85 rr                        STA     MSGL
000394r 1  A9 rr                        LDA     #>MSG9
000396r 1  85 rr                        STA     MSGH
000398r 1  20 rr rr                     JSR     SHWMSG
00039Br 1  4C rr rr                     JMP     NEXT_CHAR
00039Er 1               
00039Er 1               CMD_HELP:
00039Er 1  85 rr                        STA     LAST_CMD
0003A0r 1  A9 rr                        LDA     #<HELP
0003A2r 1  85 rr                        STA     MSGL
0003A4r 1  A9 rr                        LDA     #>HELP
0003A6r 1  85 rr                        STA     MSGH
0003A8r 1  20 rr rr                     JSR     SHWMSG
0003ABr 1  A9 rr                        LDA     #<HELP1
0003ADr 1  85 rr                        STA     MSGL
0003AFr 1  A9 rr                        LDA     #>HELP1
0003B1r 1  85 rr                        STA     MSGH
0003B3r 1  20 rr rr                     JSR     SHWMSG
0003B6r 1  4C rr rr                     JMP     NEXT_CHAR
0003B9r 1               
0003B9r 1               
0003B9r 1               
0003B9r 1               ;;ROL_LEFT_SAFE:
0003B9r 1               ;;                JSR     HEX_2_ASC_SAFE
0003B9r 1               ;;                BCC     ROL_FIM
0003B9r 1               ;;                ROL
0003B9r 1               ;;                ROL
0003B9r 1               ;;                ROL
0003B9r 1               ;;                ROL
0003B9r 1               ;;                AND     #$F0
0003B9r 1               ;;                SEC
0003B9r 1               ;;                RTS
0003B9r 1               ;;GET_DIG_RIGHT_SAFE:
0003B9r 1               ;;                JSR     HEX_2_ASC_SAFE
0003B9r 1               ;;                BCC     ROL_FIM
0003B9r 1               ;;                AND     #$0F
0003B9r 1               ;;                SEC
0003B9r 1               ;;                RTS
0003B9r 1               ;;
0003B9r 1               ;;ROL_FIM:
0003B9r 1               ;;                LDA     #<MSG6
0003B9r 1               ;;                STA     MSGL
0003B9r 1               ;;                LDA     #>MSG6
0003B9r 1               ;;                STA     MSGH
0003B9r 1               ;;                JSR     SHWMSG
0003B9r 1               ;;                LDA     ERR01
0003B9r 1               ;;                STA     ERRO
0003B9r 1               ;;                CLC
0003B9r 1               ;;                RTS
0003B9r 1               ;;
0003B9r 1               ;;
0003B9r 1               ;;CONV_ADDR_TO_HEX_APAGARD_METODO_ANTIGO:
0003B9r 1               ;;                ;;Dig 4
0003B9r 1               ;;                LDA     BIN,Y
0003B9r 1               ;;                JSR     ROL_LEFT
0003B9r 1               ;;                STA     TMP
0003B9r 1               ;;                ;;Dig 3
0003B9r 1               ;;                INY
0003B9r 1               ;;                LDA     BIN,Y
0003B9r 1               ;;                JSR     GET_DIG_RIGHT
0003B9r 1               ;;                ORA     TMP
0003B9r 1               ;;                STA     TMP1
0003B9r 1               ;;                JSR     PRINT_PAR1
0003B9r 1               ;;                JSR     PRBYTE
0003B9r 1               ;;                ;;Dig 2
0003B9r 1               ;;                INY
0003B9r 1               ;;                LDA     BIN,Y
0003B9r 1               ;;                JSR     ROL_LEFT
0003B9r 1               ;;                STA     TMP
0003B9r 1               ;;                ;;Dig 1
0003B9r 1               ;;                INY
0003B9r 1               ;;                LDA     BIN,Y
0003B9r 1               ;;                JSR     GET_DIG_RIGHT
0003B9r 1               ;;                ORA     TMP
0003B9r 1               ;;                STA     TMP2
0003B9r 1               ;;                JSR     PRBYTE
0003B9r 1               ;;                JSR     PRINT_PAR2
0003B9r 1               ;;
0003B9r 1               ;;                SEC
0003B9r 1               ;;                RTS
0003B9r 1               ;;
0003B9r 1               ;;;*******************************************
0003B9r 1               ;HEX_2_ASC_SAFE:
0003B9r 1               ;Parameter: A digit to be converted
0003B9r 1               ;Return...: A digit converted
0003B9r 1               ;
0003B9r 1               ;HEX_2_ASC_SAFE:
0003B9r 1               ;;CONV_HEX_1DIG:
0003B9r 1               ;                CMP     #$30
0003B9r 1               ;                BCC     CONV_HEX_1DIG_FIM
0003B9r 1               ;                CMP     #$3A
0003B9r 1               ;                BCC     DIG_0_A_9
0003B9r 1               ;                CMP     #$41
0003B9r 1               ;                BCS     DIG_A_TO_Z
0003B9r 1               ;                ;CARACTER PODE SER UM DESSES : ; < = > ? @
0003B9r 1               ;                CLC     ;CLEAR CARRY FLAG DIG NOT CONVERTED
0003B9r 1               ;                RTS
0003B9r 1               ;DIG_A_TO_Z:
0003B9r 1               ;                CMP     #$47
0003B9r 1               ;                BCS     CONV_HEX_1DIG_FIM
0003B9r 1               ;                SEC     ;Flag carry seted does not borrow
0003B9r 1               ;                SBC     #$37
0003B9r 1               ;                SEC     ;SET CARRY FLAG TO SIGN DIG CONVERTED
0003B9r 1               ;                RTS
0003B9r 1               ;DIG_0_A_9:
0003B9r 1               ;                SEC      ;Flag carry seted does not borrow
0003B9r 1               ;                SBC     #$30
0003B9r 1               ;                SEC     ;SET CARRY FLAG TO SIGN DIG CONVERTED
0003B9r 1               ;                RTS
0003B9r 1               ;CONV_HEX_1DIG_FIM:
0003B9r 1               ;                CLC
0003B9r 1               ;                RTS
0003B9r 1               
0003B9r 1  0D 0A 50 44  MSG1:            .byte CR,LF,"PDSILVA - BIOSMON 2024 - Version: ",VERSION,CR,0
0003BDr 1  53 49 4C 56  
0003C1r 1  41 20 2D 20  
0003E4r 1  49 6E 70 75  MSG2:            .byte "Input data: ",CR,0
0003E8r 1  74 20 64 61  
0003ECr 1  74 61 3A 20  
0003F2r 1  0A 44 75 6D  MSG3:            .byte LF,"Dump Mem. Addr: Fmt XXXX.XXXX or XXXX:",CR,0
0003F6r 1  70 20 4D 65  
0003FAr 1  6D 2E 20 41  
00041Br 1  52 75 6E 20  MSG4:            .byte "Run program in Addr: Format abcd",CR,0
00041Fr 1  70 72 6F 67  
000423r 1  72 61 6D 20  
00043Dr 1  45 58 45 43  MSG5:            .byte "EXECUTADO",CR,0
000441r 1  55 54 41 44  
000445r 1  4F 0D 00     
000448r 1  48 65 78 20  MSG6:            .byte "Hex conv. error",CR,0
00044Cr 1  63 6F 6E 76  
000450r 1  2E 20 65 72  
000459r 1  0A 50 6F 6B  MSG7:            .byte LF,"Poke: Fmt addr:dt",CR,0
00045Dr 1  65 3A 20 46  
000461r 1  6D 74 20 61  
00046Dr 1  0A 43 6F 70  MSG8:            .byte LF,"Copy block:  AddrFrom AddrTo Lenght(XXXX.XXXX:XXXX)",CR,0
000471r 1  79 20 62 6C  
000475r 1  6F 63 6B 3A  
0004A3r 1  53 79 6E 74  MSG9:            .byte "Syntax error",CR,0
0004A7r 1  61 78 20 65  
0004ABr 1  72 72 6F 72  
0004B1r 1  54 75 72 6E  MSG10:           .byte "Turn on/off character echo",CR,0
0004B5r 1  20 6F 6E 2F  
0004B9r 1  6F 66 66 20  
0004CDr 1  0A 46 69 6C  MSG11:           .byte LF,"Fill block:  AddrFrom AddrTo data(XXXX.XXXX:XX)",CR,0
0004D1r 1  6C 20 62 6C  
0004D5r 1  6F 63 6B 3A  
0004FFr 1               
0004FFr 1               ;;Help
0004FFr 1  0D 48 65 6C  HELP:            .byte CR,"Help for biosmon Version: "
000503r 1  70 20 66 6F  
000507r 1  72 20 62 69  
00051Ar 1  30 2E 30 2E                   .byte VERSION,CR,LF
00051Er 1  35 0D 0A     
000521r 1  43 6F 6D 6D                   .byte "Commands:",CR
000525r 1  61 6E 64 73  
000529r 1  3A 0D        
00052Br 1  20 20 20 20                   .byte "         B - memory Block copy",CR
00052Fr 1  20 20 20 20  
000533r 1  20 42 20 2D  
00054Ar 1  20 20 20 20                   .byte "         D - Dump memory",CR
00054Er 1  20 20 20 20  
000552r 1  20 44 20 2D  
000563r 1  20 20 20 20                   .byte "         F - Fill memory",CR,0
000567r 1  20 20 20 20  
00056Br 1  20 46 20 2D  
00057Dr 1  20 20 20 20  HELP1:           .byte "         M - Memory poke",CR
000581r 1  20 20 20 20  
000585r 1  20 4D 20 2D  
000596r 1  20 20 20 20                   .byte "         P - Peek memory",CR
00059Ar 1  20 20 20 20  
00059Er 1  20 50 20 2D  
0005AFr 1  20 20 20 20                   .byte "         R - Run program",CR
0005B3r 1  20 20 20 20  
0005B7r 1  20 52 20 2D  
0005C8r 1  20 20 20 20                   .byte "         * - Turn on/off character echo",CR
0005CCr 1  20 20 20 20  
0005D0r 1  20 2A 20 2D  
0005F0r 1  20 20 20 20                   .byte "         ? - Show help",CR,LF,0
0005F4r 1  20 20 20 20  
0005F8r 1  20 3F 20 2D  
000609r 1               
000609r 1               ;Used just for test of run cmd.
000609r 1               
000609r 1               OLD_WOZ:
000609r 1  A9 rr                        LDA     #<MSG5
00060Br 1  85 rr                        STA     MSGL
00060Dr 1  A9 rr                        LDA     #>MSG5
00060Fr 1  85 rr                        STA     MSGH
000611r 1  20 rr rr                     JSR     SHWMSG
000614r 1  4C rr rr                     JMP     NEXT_CHAR
000617r 1               
000617r 1               .include "drv16550.s"
000617r 2               .segment "DRV"
000000r 2               
000000r 2               ;Uart registers
000000r 2               PORT = $B000            ;;Uart address
000000r 2               R_RX = $00    ;;receiver buffer register (read only)
000000r 2               R_TX = $00    ;;transmitter holding register (write only)
000000r 2               RDLL = $00    ;;divisor latch LSB (if DLAB=1)
000000r 2               RDLH = $01    ;;divisor latch HSB (if DLAB=1)
000000r 2               RIER = $01    ;;interrupt enable register
000000r 2               RIIR = $02    ;;interrupt identification register
000000r 2               RFCR = $02    ;;FIFO control register
000000r 2               RLCR = $03    ;;line control register
000000r 2               RMCR = $04    ;;modem control register
000000r 2               RLSR = $05    ;;line status register
000000r 2               RMSR = $06    ;;modem status register
000000r 2               RSCR = $07	;;scratch register
000000r 2               
000000r 2               ; Constants
000000r 2               .if .not .def(CR)
000000r 2               	CR  = $0D ; Carriage Return
000000r 2               .endif
000000r 2               .if .not .def(LF)
000000r 2               	LF  = $0A ; Line feed
000000r 2               .endif
000000r 2               
000000r 2               DIV_4800_LO   = 24
000000r 2               DIV_4800_HI   = 0
000000r 2               DIV_9600_LO   = 12
000000r 2               DIV_9600_HI   = 0
000000r 2               DIV_19200_LO  = 6
000000r 2               DIV_19200_HI  = 0
000000r 2               DIV_115200_LO = 1
000000r 2               DIV_115200_HI = 0
000000r 2               POLLED_MODE   = %00000000
000000r 2               LCR_8N1       = %00000011
000000r 2               DLAB          = %10000000
000000r 2               FIFO_ENABLE   = %00000111 ;%00000111
000000r 2               THR_EMPTY     = %01100000       ;;
000000r 2               
000000r 2               DATA_READY  = %00000001
000000r 2               OVERRUN_ERR = %00000010
000000r 2               PARITY_ERR  = %00000100
000000r 2               FRAMING_ERR = %00001000
000000r 2               BREAK_INT   = %00010000
000000r 2               MCR_DTR  = $01  ;dtr output
000000r 2               MCR_RTS  = $02  ;rts output
000000r 2               MCR_OUT1 = $04  ;output #1
000000r 2               MCR_OUT2 = $08  ;output #2
000000r 2               MCR_LOOP = $10  ;loop back
000000r 2               MCR_AFCE = $20  ;auto flow control enable
000000r 2               
000000r 2               
000000r 2               INITUART:
000000r 2  A9 80            LDA        #DLAB               ;set the divisor latch access bit (DLAB)
000002r 2  8D 03 B0         STA        PORT+RLCR
000005r 2  A9 0C            LDA        #DIV_9600_LO        ;store divisor low byte (9600 baud @ 1,8 MHz clock)
000007r 2  8D 00 B0         STA        PORT+RDLL
00000Ar 2  A9 00            LDA        #DIV_9600_HI        ;store divisor hi byte
00000Cr 2  8D 01 B0         STA        PORT+RDLH
00000Fr 2  A9 07            LDA        #FIFO_ENABLE        ;enable the UART FIFO
000011r 2  8D 02 B0         STA        PORT+RFCR
000014r 2  A9 00            LDA        #POLLED_MODE	       ;disable all interrupts
000016r 2  8D 01 B0         STA        PORT+RIER
000019r 2  A9 03        	LDA        #LCR_8N1            ;set 8 data bits, 1 stop bit, no parity, disable DLAB
00001Br 2  8D 03 B0         STA        PORT+RLCR
00001Er 2  A9 2B            LDA        #MCR_OUT2 + MCR_RTS + MCR_DTR + MCR_AFCE
000020r 2  8D 04 B0         STA        PORT+RMCR
000023r 2  AD 00 B0         LDA        PORT+R_RX           ;Clear RX buffer
000026r 2  60               RTS
000027r 2               
000027r 2               
000027r 2               ; A: Data read
000027r 2               ; Returns:  F = C if character read
000027r 2               ;           F = NC if no character read
000027r 2               ; FUNÇÃO BLOCANTE COM CARACTER ECHO
000027r 2               B_READ_BYTE_ECHO:
000027r 2               READ_BYTE:
000027r 2  AD 05 B0     	LDA PORT+RLSR 												    ;// check the line status register:
00002Ar 2  29 1E        	AND #(OVERRUN_ERR | PARITY_ERR | FRAMING_ERR | BREAK_INT)   ; check for errors
00002Cr 2  F0 06        	BEQ NO_ERR 												    ;// if no error bits, are set, no error
00002Er 2  AD 00 B0     	LDA PORT+R_RX
000031r 2  4C rr rr     	JMP READ_BYTE
000034r 2               NO_ERR:
000034r 2  AD 05 B0     	LDA PORT+RLSR 												    ;// reload the line status register
000037r 2  29 01        	AND #DATA_READY
000039r 2  F0 EC        	BEQ READ_BYTE   											;// if data ready is not set, loop
00003Br 2  AD 00 B0     	LDA PORT+R_RX
00003Er 2               ;ECHO CHAR
00003Er 2  20 rr rr         JSR WRITE_BYTE
000041r 2               ;*********
000041r 2  38           	SEC		    										;// otherwise, we have data! Load it. 				    									;// clear the carry flag to indicate no error
000042r 2  60           	RTS
000043r 2               										    ;// otherwise, there was an error. Clear the error byte
000043r 2               
000043r 2               ;*************************************************
000043r 2               ; A: Data to write
000043r 2               ;
000043r 2               WRITE_BYTE:
000043r 2  85 rr            STA     RACC                     ; Save A Reg
000045r 2               WAIT_FOR_THR_EMPTY:
000045r 2  AD 05 B0         LDA     PORT+RLSR           ; Get the Line Status Register
000048r 2  29 60            AND     #THR_EMPTY          ; Check for TX empty
00004Ar 2  F0 F9            BEQ     WAIT_FOR_THR_EMPTY 	; loop while the THR is not empty
00004Cr 2  A5 rr        	LDA     RACC                ;
00004Er 2  8D 00 B0     	STA     PORT+R_TX 			; send the byte
000051r 2               ;;DELAY BETWEEN CHAR SENT
000051r 2               
000051r 2  A9 FF            LDA     #$FF
000053r 2  85 rr            STA     COUNTER
000055r 2               @txdelay:
000055r 2  C6 rr            DEC     COUNTER
000057r 2  D0 FC            BNE     @txdelay
000059r 2               
000059r 2  A5 rr            LDA     RACC
00005Br 2  20 rr rr         JSR     WRITE_LF
00005Er 2               FIM:
00005Er 2  A5 rr            LDA     RACC                     ; Restore A Reg
000060r 2  60               RTS
000061r 2               
000061r 2               WRITE_LF:
000061r 2  C9 0D            CMP     #$0D
000063r 2  D0 0C            BNE     WRITE_BYTE_WITH_ECHO_FIM
000065r 2               @WAIT_FOR_THR_EMPTY:
000065r 2  AD 05 B0         LDA     PORT+RLSR           ; Get the Line Status Register
000068r 2  29 60            AND     #THR_EMPTY          ; Check for TX empty
00006Ar 2  F0 F9            BEQ     @WAIT_FOR_THR_EMPTY 	; loop while the THR is not empty
00006Cr 2  A9 0A            LDA     #$0A
00006Er 2  8D 00 B0     	STA     PORT+R_TX 			; send the byte
000071r 2               WRITE_BYTE_WITH_ECHO_FIM:
000071r 2  60               RTS
000072r 2               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
000072r 2               ; READ_BYTE_NB: Read byte from UART waiting for it (NO BLOCANT) No echo
000072r 2               ; Registers changed: A, Y
000072r 2               ; Flag CARRY: Set when character ready
000072r 2               ;             Clear when no character ready
000072r 2               READ_BYTE_NB:
000072r 2  AD 05 B0     	LDA PORT+RLSR 												;// check the line status register:
000075r 2  29 1E        	AND #(OVERRUN_ERR | PARITY_ERR | FRAMING_ERR | BREAK_INT)   ; check for errors
000077r 2  F0 06        	BEQ @NO_ERR 												    ;// if no error bits, are set, no error
000079r 2  AD 00 B0     	LDA PORT+R_RX
00007Cr 2  4C rr rr     	JMP NO_CHAR
00007Fr 2               @NO_ERR:
00007Fr 2  AD 05 B0     	LDA PORT+RLSR 												    ;// reload the line status register
000082r 2  29 01        	AND #DATA_READY
000084r 2  F0 0B        	BEQ NO_CHAR   											;// if data ready is not set, loop
000086r 2  AD 00 B0     	LDA PORT+R_RX
000089r 2  20 rr rr         JSR     WRITE_BYTE
00008Cr 2  20 rr rr         JSR     ACC_DELAY
00008Fr 2  38           	SEC		    										;// otherwise, we have data! Load it. 				    									;// clear the carry flag to indicate no error
000090r 2  60           	RTS
000091r 2               NO_CHAR:
000091r 2  20 rr rr         JSR     ACC_DELAY
000094r 2  18               CLC
000095r 2  60               RTS
000096r 2               
000096r 2               ACC_DELAY:
000096r 2  48               PHA
000097r 2  A0 FF            LDY     #$FF
000099r 2               @txdelay1:
000099r 2  88               DEY
00009Ar 2  D0 FD            BNE     @txdelay1
00009Cr 2  68               PLA
00009Dr 2  60               RTS
00009Er 2               
00009Er 1               
00009Er 1               .segment "RESETVEC"
000000r 1               
000000r 1  00 0F                        .word   $0F00          ; NMI vector
000002r 1  rr rr                        .word   RESET          ; RESET vector
000004r 1  00 00                        .word   $0000          ; IRQ vector
000004r 1               
